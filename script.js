let codeEditorContent = `import pennylane as qml
from pennylane import numpy as np
from dynex import dynex_circuit

# Define a Pennylane Quantum Circuit for a simple 3x3 Sudoku model
n_qubits = 6

def PLCircuit(params):
    wires = range(n_qubits)

    # Apply Hadamard gates
    for w in wires:
        qml.Hadamard(wires=w)

    # Apply CNOT gates to enforce some constraints
    qml.CNOT(wires=[0, 1]);
    qml.CNOT(wires=[2, 3]);
    qml.CNOT(wires=[4, 5]);

    qml.CNOT(wires=[1, 2]);
    qml.CNOT(wires=[3, 4]);
    qml.CNOT(wires=[5, 0]);

    return qml.state()

params = []
wires = range(n_qubits)
measure = dynex_circuit.execute(PLCircuit, params, wires, debugging=False, mainnet=True, is_cluster=True, description="DynexGPT-BETA", method='measure', shots=1)

print(measure)
#[SamerRahmeh-LOG]:: This code has been generated by DynexGPT-BETA`; // This will be replaced with POST code from the DynexSolver

let codeMirrorInstance = null;
function getElement(id) {
    return document.getElementById(id);
}

function addRule(value = "", isFirst = false) {
    const rulesList = getElement("rules-list");
    if (!rulesList) return;

    const newRuleItem = document.createElement("div");
    newRuleItem.className = "rule-item flex items-center gap-1.5";

    const newInput = document.createElement("input");
    newInput.type = "text";
    newInput.placeholder = "enter rule";
    newInput.value = value;
    newInput.className = "outline-none mt-1 block border-2 py-2 px-4 border-gray-200 rounded-md";
    newInput.style.fontSize = "14px";
    newInput.style.flex = "1";

    newRuleItem.appendChild(newInput);

    if (!isFirst) {
        const newButton = document.createElement("button");
        newButton.className = "flex items-center justify-center bg-white border-2 border-gray-200 rounded-md hover:bg-gray-100 mt-1";
        newButton.style.padding = "10.8px 0.75rem";

        const newIcon = document.createElement("i");
        newIcon.className = "fas fa-trash text-red-600";
        newButton.appendChild(newIcon);

        newRuleItem.appendChild(newButton);

        newButton.addEventListener("click", function () {
            newRuleItem.remove();
        });
    }

    rulesList.appendChild(newRuleItem);
}
function clearRules() {
    const rulesList = getElement("rules-list");
    if (rulesList) {
        rulesList.innerHTML = '';
    }
}

function loadSavedRules() {
    clearRules();
    const savedRules = JSON.parse(localStorage.getItem("rules")) || [];

    if (savedRules.length === 0) {
        addRule("", true);
    } else {
        savedRules.forEach((rule, index) => addRule(rule, index === 0));
    }
}

// Function to save form data to localStorage
function saveFormData() {
    const title = getElement("title")?.value || "";
    const rules = Array.from(
        document.querySelectorAll("#rules-list input[type='text']")
    ).map((input) => input.value);
    const chatgpt4Checked = getElement("check")?.checked || false;
    const termsChecked = getElement("terms")?.checked || false;

    localStorage.setItem("title", title);
    localStorage.setItem("rules", JSON.stringify(rules));
    localStorage.setItem("chatgpt4", chatgpt4Checked);
    localStorage.setItem("terms", termsChecked);
}
function initializeCodeMirror(content) {
  const editorElement = getElement("code-mirror-editor");
  if (!editorElement) return;

  editorElement.innerHTML = '';
  if (codeMirrorInstance && typeof codeMirrorInstance.toTextArea === 'function') {
      codeMirrorInstance.toTextArea();
  } else if (codeMirrorInstance) {
      const cmWrapper = editorElement.querySelector('.CodeMirror');
      if (cmWrapper) {
          editorElement.removeChild(cmWrapper);
      }
  }

  codeMirrorInstance = CodeMirror(editorElement, {
      value: content,
      mode: "python",
      theme: "material",
      lineNumbers: false,
      readOnly: true,
      lineWrapping: true,
  });

  codeMirrorInstance.setSize("100%", "450px");
  codeMirrorInstance.refresh();
}
function showGeneratedContent() {
    getElement('form-section')?.classList.add('hidden');
    getElement('loading')?.classList.add('hidden');
    getElement('generated-content')?.classList.remove('hidden');
    initializeCodeMirror(codeEditorContent);
}
function executeAndGetCode() {
    saveFormData();
    getElement('form-section')?.classList.add('hidden');
    getElement('loading')?.classList.remove('hidden');
    setTimeout(() => {
        showGeneratedContent();
    }, 1500); // this will be replaced with actual loading time from DynexSolver
}

function tryAgain() {
    getElement('generated-content')?.classList.add('hidden');
    getElement('form-section')?.classList.remove('hidden');
    loadSavedFormData();
}

function loadSavedFormData() {
    const titleElement = getElement("title");
    if (titleElement) {
        titleElement.value = localStorage.getItem("title") || "";
    }

    loadSavedRules();

    const chatgptCheckbox = getElement("check");
    if (chatgptCheckbox) {
        chatgptCheckbox.checked = localStorage.getItem("chatgpt4") === "true";
    }

    const termsCheckbox = getElement("terms");
    if (termsCheckbox) {
        termsCheckbox.checked = localStorage.getItem("terms") === "true";
    }
}

function initializePage() {
    loadSavedFormData();

    const executeButton = document.querySelector('.get-code');
    if (executeButton) {
        executeButton.addEventListener('click', executeAndGetCode);
    }

    const tryAgainButton = document.querySelector('.get-code1');
    if (tryAgainButton) {
        tryAgainButton.addEventListener('click', tryAgain);
    }

    const addRuleButton = getElement('add-rule-button');
    if (addRuleButton) {
        addRuleButton.addEventListener('click', () => addRule());
    }
}

document.addEventListener("DOMContentLoaded", initializePage);